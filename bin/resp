# #!/usr/bin/env python

# import yaml
# import glob
# import argparse
# import concurrent.futures

# from rdkit import Chem

# import MDAnalysis as mda
# import psiresp as sip
# from psiresp.utils import rdmols_to_inter_chrequiv

# parser = argparse.ArgumentParser("Run resp")
# parser.add_argument("input", help="input yaml file")
# parser.add_argument('-mem', '--memory', dest='memory', default='4GB', help='memory')
# parser.add_argument('-nt', '--nthreads', dest='nthreads', type=int, default=8, help='number of threads')


# def read(yamlfile):
#     with open(yamlfile, "r") as f:
#         return yaml.load(f, Loader=yaml.FullLoader)


# def submit(executor, method, objects):
#     futures = [executor.submit(getattr(o, method)) for o in objects]
#     try:
#         concurrent.futures.wait(futures)
#     except KeyboardInterrupt:
#         executor.shutdown(wait=False)
#         raise KeyboardInterrupt()
#     else:
#         results = [f.result() for f in futures]
#         not_none = [x for x in results if x]
#         if not_none:
#             return "\n".join(not_none)


# def run_job(executor,
#             equiv_mcs=False,
#             mcs_natoms=4,
#             stage_2=True,
#             inter_chrconstr=[],
#             inter_chrequiv=[],
#             equivalent_methyls=False,
#             hyp_a1=0.0005,
#             hyp_a2=0.001,
#             hyp_b=0.1,
#             ihfree=True,
#             tol=1e-5,
#             maxiter=50,
#             restraint=True,
#             molecules={},
#             n_orient=8,
#             n_translate=0,
#             n_rotate=0,
#             **kwargs):

#     intra_chrconstr = [m.pop("chrconstr", []) for m in molecules.values()]
#     intra_chrequiv = [m.pop("chrequiv", []) for m in molecules.values()]

#     # intra_chrconstr, intra_chrequiv = clean_intra(intra_chrconstr,
#     #                                               intra_chrequiv)

#     mol_kwargs = []
#     for name, molkwargs in molecules.items():
#         dct = dict(**kwargs, **molkwargs)
#         dct["name"] = name
#         mol_kwargs.append(dct)

#     rdmols = [load_rdmol(**kw) for kw in mol_kwargs]

#     if isinstance(inter_chrequiv, dict):
#         inter_chrequiv = inter_chrequiv.items()
#     inter_chrequiv = list(inter_chrequiv)

#     if equiv_mcs:
#         inter_chrequiv += rdmols_to_inter_chrequiv(rdmols, mcs_natoms)

#     resps = []
#     out_files = []

#     for rdmol, molkwargs in zip(rdmols, mol_kwargs):
#         out = molkwargs.pop("out", "{name}_charged.pdb")
#         out_files.append(out.format(**molkwargs))
#         molkwargs.pop("coords", None)
#         molkwargs.pop("rdmol", None)

#         resps.append(sip.Resp.from_rdmol(rdmol, executor=executor, **molkwargs))

#     result = submit(executor, "compute_opt", resps)
#     if result:
#         return result

#     for resp in resps:
#         resp.add_orientations(n_orient=n_orient, n_rotate=n_rotate, n_translate=n_translate)

#     result = submit(executor, "compute_esp", resps)
#     if result:
#         return result

#     mresp = sip.MultiResp(resps)

#     mresp.run(stage_2=stage_2,
#               intra_chrconstr=intra_chrconstr,
#               inter_chrconstr=inter_chrconstr,
#               intra_chrequiv=intra_chrequiv,
#               inter_chrequiv=inter_chrequiv,
#               equivalent_methyls=equivalent_methyls,
#               hyp_a1=hyp_a1,
#               hyp_a2=hyp_a2,
#               ihfree=ihfree,
#               tol=tol,
#               maxiter=maxiter,
#               restraint=restraint)

#     for out, mol in zip(out_files, mresp.molecules):
#         mol.write(out)
#         print(f"Wrote {out}")


# def load_rdmol(name=None, coords="{name}*.xyz", rdmol=None, **kwargs):
#     if coords is not None:
#         coordfiles = glob.glob(coords.format(name=name))
#     else:
#         coordfiles = []
#     if rdmol is None:
#         try:
#             rdmol = coordfiles[0]
#         except IndexError:
#             raise ValueError("At least one of `coords` or `rdmol` " "must be provided")

#     mol = sip.utils.get_rdmol(rdmol, name)
#     n_atoms = mol.GetNumAtoms()
#     for file in coordfiles:
#         conf = Chem.Conformer(n_atoms)
#         pos = mda.Universe(file).atoms.positions.astype(float)
#         for i, row in enumerate(pos):
#             conf.SetAtomPosition(i, row)
#         mol.AddConformer(conf)
#     Chem.SanitizeMol(mol)
#     Chem.AssignStereochemistryFrom3D(mol)
#     Chem.SetDoubleBondNeighborDirections(mol)
#     return mol


# if __name__ == "__main__":
#     args = parser.parse_args()
#     contents = read(args.input)
#     molecules = contents.pop("molecules", {})
#     executor = concurrent.futures.ThreadPoolExecutor()

#     returned = run_job(executor, **contents, molecules=molecules)
#     if returned is not None:
#         print(returned)
